#!/bin/sh
# pfIP Reputation Manager 2.3.3 - By BBcan177@gmail.com - 04-12-14
# Copyright (C) 2014 BBcan177@gmail.com
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License Version 2 as
# published by the Free Software Foundation.  You may not use, modify or
# distribute this program under any other version of the GNU General
# Public License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
#
#     IP Reputation Manager Script
#
#     DO NOT RUN THIS FILE directly.
#
#     Use pfiprep to execute ( Which contains user configurable settings )
#
 
now=$(date); echo; echo "**** UPDATE PROCESS INITIATED - " $now " ****"; echo; now=$(date +%k)
 
# ================================================================
#     Check if another pfIPrep process is currently operational.
# ================================================================
 
if [ ! -f $pfipreplock ]; then
        if [ "$plog" == "yes" ]; then $pathlogger -t pfIPrep "Cannot continue, pfIPrep is currently in Operation . [ $pfipreplock ] exists"; fi
        echo "Cannot continue, pfIPrep is currently in Operation"
        exit 1
fi
 
# ================================================================
#         Check to see if Dependencies are Installed
# ================================================================
if [ ! -x $pathgrepcidr ]; then echo "Application [ Grepcidr ] Not found. Can't proceed."; exit; fi
if [ "$dmethod" == "fetch" -a ! -x $pathfetch ]; then echo "Application [ Fetch ] not found. Can't proceed."; exit; fi
if [ "$dmethod" == "wget" -a ! -x $pathwget ]; then echo "Application [ wget ] not found. Can't proceed."; exit; fi
# ================================================================
 
killdbfunction() {
# Fresh Start process to clear database
# To call this function [  ./pfiprep killdb  ] or [  ./pfiprep killdb dskip  ]
echo " Deleting pfIP Rep Databases."
rm -r $masterfile; rm -r $mastercat; rm -r $mastermatch
rm -r $pforigdir; rm -r $pfdir; rm -r $pfmatch
echo; echo "Databases have been Deleted!"; echo
bypass=yes
}
 
# Create Files/Folders as required
tempfile=/tmp/listtemp
tempfile2=/tmp/listtemp2
dupfile=/tmp/duptemp
dedupfile=/tmp/deduptemp
addfile=/tmp/addfile
syncfile=/tmp/syncfile
matchfile=/tmp/matchfile
tempmatchfile=/tmp/tempmatchfile
ccbinarylock=$userfolder/cc_binary.lock
cccsvlock=$userfolder/cc_csv.lock
# Store "Match" d-dedups in matchdedup.txt file
matchdedup=matchdedup.txt
 
if [ ! -f $tempfile ]; then touch $tempfile; fi
if [ ! -f $tempfile2 ]; then touch $tempfile2; fi
if [ ! -f $dupfile ]; then touch $dupfile; fi
if [ ! -f $dedupfile ]; then touch $dedupfile; fi
if [ ! -f $addfile ]; then touch $addfile; fi
if [ ! -f $syncfile ]; then touch $syncfile; fi
if [ ! -f $matchfile ]; then touch $matchfile; fi
if [ ! -f $tempmatchfile ]; then touch $tempmatchfile; fi
 
clearvars(){
header=""; addr=""; infile=""; outfile=""; process=""; logentry=""; eventnow=""; dup=""; data=""; ccheck=""
A=""; A1=""; B=""; B1=""; diff=""; count=""; i=""; ii=""; list=""; data=""; ip=""; file=""; proceed=0; pcount=""
icount=""; iicount=""; fcount=""; hcheck=""; lcheck=""; countm=""; counto=""; safe=""; dcount=""; mcount=""
passupdate=""; tierlist=""; groupname=""; mmcount=""; urldata=""; urlepoch=""; var=""; var2=""; d=""; killdb=""
> $tempfile; > $tempfile2; > $dupfile; > $dedupfile; > $addfile; > $tempmatchfile; > $matchfile
}
 
# ================================================================
#    Processes to extract IP addresses from Downloaded Blocklist
# ================================================================
 
##########
# Primary Process to extract IP addresses from Downloaded Blocklist
process(){
grep -aoEw -e "(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?/[0-9]{2})" -e "(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)" $workdir$infile | grep -Ev "^(192\.168|10\.|172\.1[6789]\.|172\.2[0-9]\.|172\.3[01]\.|127\.0\.0\.1|0\.0\.0\.0)" | sort | uniq > $pforigdir$outfile
cp $pforigdir$outfile $pfdir$outfile
 
cicount=$(grep -cv '^#\|^$' $workdir$infile); cocount=$(grep -cv "^1\.1\.1\.1" $pfdir$outfile)
echo; echo "Download file count [ $cicount ]  Outfile count [ $cocount ]"
}
 
##########
# Process to extract IP addresses from Downloaded Blocklist - Zip Downloads
processtar(){
tar -xOf $workdir$infile | tr , '\n' | grep -aoEw -e "(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?/[0-9]{2})" -e "(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)" |
        grep -Ev '^(192\.168|10\.|172\.1[6789]\.|172\.2[0-9]\.|172\.3[01]\.|127\.0\.0\.1|0\.0\.0\.0)' | sort | uniq > $pforigdir$outfile
cp $pforigdir$outfile $pfdir$outfile
 
cocount=$(grep -cv "^1\.1\.1\.1" $pfdir$outfile)
echo; echo "Download file count [ tar file ]  Outfile count [ $cocount ]"
}
 
##########
# Process to extract IP addresses from Block Type Lists ie-dShield block.txt
processblock(){
grep -aoEw -e "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0]{1}" $workdir$infile |
        grep -Ev '^(192\.168|10\.|172\.1[6789]\.|172\.2[0-9]\.|172\.3[01]\.|127\.0\.0\.1|0\.0\.0\.0)' | sort | uniq |
        cut -d '.' -f 1-3 | sed 's/$/.0\/24/' > $pforigdir$outfile
        cp $pforigdir$outfile $pfdir$outfile
 
cocount=$(grep -cv "^1\.1\.1\.1" $pfdir$outfile)
echo; echo "Outfile count [ $cocount ]"
}
 
##########
# Process to extract IP addresses from Downloaded Blocklist - IBlock list range type (GZ Format)
processib(){
data="$($pathgunzip -c $workdir$infile | grep -v '^#\|^$\|^:' | sed 's/^.*://' | sort | uniq)"
echo "$data" > $pforigdir$outfile
if [ -e "$pfdir$outfile" ]; then rm $pfdir$outfile; fi
icount=0; iicount=0; [ -x $pathenum ] && pathjot=$pathenum
for i in $data; do
        A="${i%-*}"; B="${i#*-}"
        A1="${A##*.}"; B1="${B##*.}"
        diff=$(($B1 - $A1))
        if [ "$B1" -eq "255" ]; then diff=254; fi
        icount=$(($diff + 1))
        if [ "$p24" == "no" ]; then
                if [ "$diff" -eq "0" ]; then
                        echo $A >> $pfdir$outfile
        else
                        echo $A >> $pfdir$outfile
                        for a in $($pathjot "$diff"); do
                                count=$(($A1 + $a))
                                echo "${A%.*}.$count" >> $pfdir$outfile
                        done
        fi
        else
                if [ "$diff" -eq "0" ]; then
                        echo $A >> $pfdir$outfile
                elif [ "$diff" -gt "0" -a "$diff" -le $max ]; then
                        echo $A >> $pfdir$outfile
                        for a in $($pathjot "$diff"); do
                                count=$(($A1 + $a))
                                echo "${A%.*}.$count" >> $pfdir$outfile
                        done
                else
                        echo "${A%.*}.0/24" >> $pfdir$outfile
                fi
        fi
        iicount=$(($icount + $iicount))
done
 
grep -Ev '^(192\.168|10\.|172\.1[6789]\.|172\.2[0-9]\.|172\.3[01]\.|127\.0\.0\.1|0\.0\.0\.0)' $pfdir$outfile > $tempfile; mv -f $tempfile $pfdir$outfile
cicount=$(echo "$data" | grep -cv '^#\|^$'); cocount=$(grep -cv "^1\.1\.1\.1" $pfdir$outfile)
echo; echo "Raw Download file count [ $cicount ] Original IP Calculated count [ $iicount ] Outfile iBlock count [ $cocount ]"
}
 
##########
# Process to Download a website html and collect IPs for the "keepdays" variable on multiple web pages
processrecursive() {
 
keepsec=$((86400 * $keepdays)); maxepoch=$((`date '+%s'` - $keepsec))
> $tempfile; > $tempfile2; echo
urldata=$(grep -oEw "[0-9]{4}/[0-9]{2}/[0-9]{2}/index.html" $workdir$infile | sort | uniq)
if [ "$dskip" == "yes" ]; then
        :
else
        for i in $urldata; do
                ii=$(echo $i | sed 's/\/index.html//')
                if [ "$(uname)" == "FreeBSD" ]; then
                        urlepoch=$((`date -j -f "%Y/%m/%d" "$ii" '+%s'` - $maxepoch))
                else
                        urlepoch=$((`date --date="$ii" +"%s"` - $maxepoch))
                fi
                if [ "$urlepoch" -ge "0" ]; then
                        echo "- Downloading [ $header ] recursively [ $i ]"
                        if [ "$dmethod" == "fetch" ]; then $pathfetch -v -o $tempfile -T 20 $addr$i
                        elif [ "$dmethod" == "wget" ]; then $pathwget --no-check-certificate -T 20 -O $tempfile $addr$i
                        else echo "No download method chosen"; returncode=1
                        fi
                        returncode=$?; echo
                        if [ "$returncode" -eq "0" ]; then cat $tempfile >> $tempfile2; fi
                fi
        done
        mv -f $tempfile2 $workdir$infile
fi
# If Download File Exists, Collect IPs and Remove RFC1918 Addresses and CIDRs and Call "Process".
if [ -s "$workdir$infile" ]; then
        process
        mv -f $pfdir$outfile $pforigdir$outfile
        grep -Ev '^(192\.168|10\.|172\.1[6789]\.|172\.2[0-9]\.|172\.3[01]\.|127\.0\.0\.1|0\.0\.0\.0)' $pforigdir$outfile |
                sort | uniq > $pfdir$outfile
 
cocount=$(grep -cv "^1\.1\.1\.1" $pfdir$outfile)
echo; echo "Outfile count [ $cocount ]"
fi
}
 
# Process to Split ET Pro IPREP into Category Files and Compile selected Blocked categories into Outfile
processet() {
 
$pathgunzip -c $workdir$infile > $pforigdir$outfile
returncode=$?
if [ "$returncode" -eq "0" ]; then
        evar="e_t*"
        # Remove Previous ET IPRep Files
        [ -d $etdir ] && [ "$(ls -A $etdir)" ] && rm $etdir/e_t*
        if [ -f $pfdir$outfile ]; then rm -r $pfdir$outfile; rm $pfdir$evar; fi
 
        # ET CSV Format (IP, Category, Score)
        echo; echo "Processing [ $header ]"
        while IFS="," read a b c
        do
        case "$b" in
                1)  echo $a >> $etdir/e_tcnc;;
                2)  echo $a >> $etdir/e_tbot;;
                3)  echo $a >> $etdir/e_tspam;;
                4)  echo $a >> $etdir/e_tdrop;;
                5)  echo $a >> $etdir/e_tspywarecnc;;
                6)  echo $a >> $etdir/e_tonlinegaming;;
                7)  echo $a >> $etdir/e_tdrivebysrc;;
                8)  echo $a >> $etdir/e_tcat8;;
                9)  echo $a >> $etdir/e_tchatserver;;
                10) echo $a >> $etdir/e_ttornode;;
                11) echo $a >> $etdir/e_tcat11;;
                12) echo $a >> $etdir/e_tcat12;;
                13) echo $a >> $etdir/e_tcompromised;;
                14) echo $a >> $etdir/e_tcat14;;
                15) echo $a >> $etdir/e_tp2p;;
                16) echo $a >> $etdir/e_tproxy;;
                17) echo $a >> $etdir/e_tipcheck;;
                18) echo $a >> $etdir/e_tcat18;;
                19) echo $a >> $etdir/e_tutility;;
                20) echo $a >> $etdir/e_tddos;;
                21) echo $a >> $etdir/e_tscanner;;
                22) echo $a >> $etdir/e_tcat22;;
                23) echo $a >> $etdir/e_tbrute;;
                24) echo $a >> $etdir/e_tfakeav;;
                25) echo $a >> $etdir/e_tdyndns;;
                26) echo $a >> $etdir/e_tundesireable;;
                27) echo $a >> $etdir/e_tabusedtld;;
                28) echo $a >> $etdir/e_tselfsignedssl;;
                29) echo $a >> $etdir/e_tblackhole;;
                30) echo $a >> $etdir/e_tras;;
                31) echo $a >> $etdir/e_tp2pcnc;;
                32) echo $a >> $etdir/e_tsharedhosting;;
                33) echo $a >> $etdir/e_tparking;;
                34) echo $a >> $etdir/e_tvpn;;
                35) echo $a >> $etdir/e_texesource;;
                36) echo $a >> $etdir/e_tcat36;;
                37) echo $a >> $etdir/e_tmobilecnc;;
                38) echo $a >> $etdir/e_tmobilespyware;;
                39) echo $a >> $etdir/e_tskypenode;;
                40) echo $a >> $etdir/e_tbitcoin;;
                41) echo $a >> $etdir/e_tddosattack;;
                *)  echo $a >> $etdir/unknown;;
        esac
        done <"$pforigdir$outfile"
 
        # Compile "Block" ET IPREP lists
        data=$(ls $etdir | tr -d '_')
        for list in $data; do
                blfile=$(echo $list | sed 's/et/e_t/')
                eval mode=\$$list
                if [ "$mode" == "block" ]; then
                        cat $etdir/$blfile >> $pfdir$outfile
                        cp $etdir/$blfile $pfdir
                fi
        done
        cicount=$(cat $etdir/e_t* | grep -cv '^#\|^$'); cocount=$(grep -cv "^1\.1\.1\.1" $pfdir$outfile)
        echo; echo "ET Folder count [ $cicount ]  Outfile count [ $cocount ]"
else
        if [ "$plog" == "yes" ]; then $pathlogger -t pfIPrep "Gunzip failed for [ $header ]"; fi
        echo "Gunzip failed for [ $header ]"
fi
}
 
 
##########
# Process to Remove IPs that are over 255 IPs in a Blocklist
process255() {
cp $pfdir$outfile $tempfile; > $dedupfile
data255="$(cut -d '.' -f 1-3 $tempfile | awk '{a[$0]++}END{for(i in a){if(a[i] > 255){print i}}}')"
if [ ! -z "$data255" ]; then
        for ip in $data255; do
                ii=$(echo "^$ip" | sed 's/\./\\\./g')
                grep $ii $tempfile >> $dedupfile
        done
        awk 'FNR==NR{a[$0];next}!($0 in a)' $dedupfile $tempfile > $pfdir$outfile
        for ip in $data255; do echo $ip"0/24" >> $pfdir$outfile; done
fi
}
 
# ================================================================
#               Sub Process to Collect Groupname
# ================================================================
 
##########
# Process to Collect Blocklist Groupname Information
casegroup() {
case "$group" in
        tier1)  tier1="$tier1 $header";;
        tier2)  tier2="$tier2 $header";;
        tier3)  tier3="$tier3 $header";;
        tier4)  tier4="$tier4 $header";;
        tier5)  tier5="$tier5 $header";;
        tier6)  tier6="$tier6 $header";;
        tier7)  tier7="$tier7 $header";;
        tier8)  tier8="$tier8 $header";;
        tier9)  tier9="$tier9 $header";;
        tier10) tier10="$tier10 $header";;
esac
}
 
##########
# Process to Download Maxmind GeoIP Country Code Database Binary First Tuesday of Each Month
countrybinary() {
 
dom=$(date +%e); returncode=0; proceed=0
 
# Only run "once" on the first Tuesday of Each month unless the bypass is set to "Yes"
if [ ! -f $pathgeoipdat ]; then proceed=1; rm -r $ccbinarylock; fi
if [ $(date +%w) -eq 2 ] && [ $dom -ge 8 -a $dom -le 14 ]; then proceed=1; fi
if [ ! -x $pathgunzip ]; then echo "Application [ Gunzip ] Not found, Can't proceed."; proceed=0; fi
mdate=$(find $pathgeoipdat -mtime +31)
if [ "$mdate" == "$pathgeoipdat" ]; then proceed=1; rm -r $ccbinarylock; fi
 
if [ "$proceed" -eq "1" ]; then
        if [ -f $ccbinarylock ]; then
                :
        else
                if [ "$dmethod" == "fetch" ]; then $pathfetch -v -o $pathgeoipdatgz -T 20 $addr$infile; fi
                if [ "$dmethod" == "wget" ]; then $pathwget --no-check-certificate -T 20 -O $pathgeoipdatgz $addr$infile; fi
                if [ "$returncode" -eq "0" ]; then $pathgunzip -f $pathgeoipdatgz; touch $ccbinarylock; fi
                if [ "$returncode" -eq "0" ]; then echo; echo "===>>  MaxMind Country Code Database Binary has been UPDATED  <<==="; echo; fi
        fi
else
        # Remove lock after the First Tuesday of each Month (If not this will repeat at each scheduled run on the First Tue of Month
        if [ -f $ccbinarylock ]; then rm $ccbinarylock; fi
fi
}
 
##########
# Process to download Country Code Database CSV from MaxMind First Tuesday of Each Month
countrycode() {
 
dom=$(date +%e); p24=no; dup=no; proceed=0; outfile="p24"$header".txt"
if [ "$1" == "remove" ]; then
        grep $header $masterfile > $tempfile
        awk 'FNR==NR{a[$0];next}!($0 in a)' $tempfile $masterfile > $tempfile2; mv -f $tempfile2 $masterfile
        sed 's/^.* //' $masterfile > $mastercat
        echo; echo "Removed Maxmind Country Code Blocklist from Database"; proceed=0
        echo; echo "Please perform a delete of the Database to re-configure without Country Code Blocking"
        # Comment-out Blocklists that are removed
        script=$(basename $0)
        sed -i ' ' '/^countrycode.*remove/ s/^/#/' $userfolder/$script
        exit
else
        # Checks to Proceed with CC Process
        if [ $(date +%w) -eq 2 ] && [ $dom -ge 8 -a $dom -le 14 ]; then proceed=1; fi
        # Update if edits were found to countrycode list file
        mdate=$(find $countrycodedir$countrycodelist -mtime -45)
        if [ ! -f $countrycodedir$countrycodelist ]; then proceed=1; rm -r $cccsvlock; fi
        if [ "$mdate" == $countrycodedir$countrycodelist ]; then echo; echo "Found modified [ $countrycodelist ] Reconfiguring"; echo; proceed=1; fi
        mdate=$(find $pathgeoipccdata -mtime +31)
        if [ "$mdate" == "$pathgeoipccdata" ]; then proceed=1; rm -r $cccsvlock; fi
        if [ ! -f $pathgeoipccdata ]; then proceed=1; rm -r $cccsvlock; fi
fi
# Cancel CC Process
if [ ! -x $pathunzip ]; then echo "Application [ Unzip ] Not found, Can't proceed."; proceed=0; fi
 
if [ "$proceed" -eq "1" ]; then
        # Only Download the CSV Database Once. Or manually delete the cccsvlock
        if [ -f $cccsvlock ]; then
                :
        else
                if [ "$dmethod" == "fetch" ]; then $pathfetch -v -o $userfolder$infile -T 20 $addr$infile; fi
                if [ "$dmethod" == "wget" ]; then $pathwget --no-check-certificate -T 20 -O $userfolder$infile $addr$infile; fi
        fi
        if [ "$returncode" -eq "0" ]; then
                # Create new default country Code List if not exist
                if [ ! -f "$countrycodelist" ]; then
                        $pathunzip -o $userfolder$infile
                        cut -d',' -f5,6 $pathgeoipccdata | sort | uniq > $countrycodelist
                fi
                cclist=$(grep "#" $countrycodelist)
                # Check if Countrycode file has any "#", if not do not proceed with Country Blocking
                if [ ! "$cclist" == "" ]; then
                        cut -d',' -f5,6 $pathgeoipccdata | sort | uniq | grep -vf $countrycodelist > $tempfile
                        cat $pathgeoipccdata | grep -vf $tempfile | cut -d',' -f1-2 | sed 's/","/-/' | sed 's/"//g' > $pfdir$outfile
                        echo; echo "===>>  MaxMind Country Code Database has Been Updated with Your CC Whitelist Settings  <<==="; echo
                        cclist=$(grep "#" $countrycodelist | cut -c 7- | tr '\n' '|')
                        echo "Whitelisted Countries [ $cclist ]"; echo
                        if [ "$plog" == "yes" ]; then $pathlogger -t pfIPrep "MaxMind Country Code Database has Been Updated"; fi
                        if ! grep -sq $event$header"-" $logfile; then echo $event$header"-" >> $logfile; fi
                        logentry=$(grep "$event"$header"-" $logfile)
                        count=$(grep -c ^ $pfdir$outfile)
                        sed -i '' -e "s/$logentry/$logentry $eventnow $count,/" $logfile
                        duplicate
                        casegroup
                        clearvars
                else
                        echo "Please edit [ $countrycodelist ] and comment "#" the countries to " SAFELIST " before proceeding with CC Blocking"; echo
                        exit
                fi
                touch $cccsvlock
        else
                echo; echo "===>>  Download for [ Maxmind GeoIP Country Code Database FAILED ! ]   <<==="
                if [ "$plog" == "yes" ]; then $pathlogger -t pfIPrep "MaxMind Country Code Database has FAILED to Update !"; fi
        fi
else
        if [ -f $cccsvlock ]; then rm $cccsvlock; fi
fi
}
 
# ================================================================
#  Blocklist Download processes 1) process24  2) duplicate
# ================================================================
 
##########
# Process to condense an IP range if a "Max" amount of IP addresses are found in a /24 range
process24() {
cp $pfdir$outfile $tempfile; > $dupfile; > $tempfile2; > $matchfile; > $tempmatchfile
data="$(cut -d '.' -f 1-3 $tempfile | awk -v max="$max" '{a[$0]++}END{for(i in a){if(a[i] > max){print i}}}')"
count=$(echo "$data" | grep -c ^); mcount=0; dcount=0; safe=0
if [ "$data" == "" ]; then count=0; fi
matchoutfile="match"$header".txt"
# Classify Repeat Offenders by Country Code
if [ -f $pathgeoipdat ]; then
        for ip in $data; do
                ccheck=$($pathgeoip -f $pathgeoipdat "$ip.1" | cut -c 24-25)
                case "$cc" in
                        *$ccheck*)
                                safe=$(($safe + 1))
                                if [ "$ccwhite" == "match" -o "$ccblack" == "match" ]; then
                                        echo "$ip." >> $matchfile
                                fi;;
                        *)
                                echo "$ip." >> $dupfile;;
                esac
        done
else
        if [ "$plog" == "yes" ]; then $pathlogger -t pfIPrep "Maxmind Binary Database Missing [ $pathgeoipdat ], skipping p24 Process"; fi
        echo; echo "Maxmind Binary Database Missing [ $pathgeoipdat ], skipping p24 Process"; echo
fi
# Collect Match File Details
if [ -s "$matchfile" -a ! "$dedup" == "yes" ]; then
        mon=$(sed -e 's/^/^/' -e 's/\./\\\./g' $matchfile)
        for ip in $mon; do
                grep $ip $tempfile >> $tempfile2
        done
        mcount=$(grep -c ^ $tempfile2)
        if [ "$ccwhite" == "match" ]; then
                sed 's/$/0\/24/' $matchfile >> $tempmatchfile
                sed 's/^/\!/' $tempfile2 >> $tempmatchfile
        fi
fi
 
# If no Matches found remove previous Matchoutfile if exists.
if [ ! -s "$tempmatchfile" -a -f $matchoutfile ]; then rm $matchoutfile; fi
# Move Match File to the Match Folder by Individual Blocklist Name
if [ -s "$tempmatchfile" ]; then mv -f $tempmatchfile $pfmatch$matchoutfile; fi
 
# Find Repeat Offenders in each individual Blocklist Outfile
if [ -s "$dupfile" ]; then
        > $tempfile2
        dup=$(sed -e 's/^/^/' -e 's/\./\\\./g' $dupfile)
        for ip in $dup; do
                grep $ip $tempfile >> $tempfile2
        done
        dcount=$(grep -c ^ $tempfile2)
        if [ "$ccblack" == "block" ]; then
                awk 'FNR==NR{a[$0];next}!($0 in a)' $tempfile2 $tempfile > $pfdir$outfile
                sed 's/$/0\/24/' $dupfile >> $pfdir$outfile
        elif [ "$ccblack" == "match" ]; then
                sed 's/$/0\/24/' $dupfile >> $tempmatchfile
                sed 's/^/\!/' $tempfile2 >> $tempmatchfile
        else
                :
        fi
fi
if [ "$count" == "0" ]; then echo "Found [ 0 ] IP range(s) over the threshold of [ $max ] p24 - CC Blacklist"; fi
if [ "$safe" == "0" ]; then echo "Found [ 0 ] IP range(s) over the threshold of [ $max ] p24 - CC Whitelist"; fi
 
if [ -s "$dupfile" -o -s "$matchfile" ]; then
echo
echo "Process /24 Stats"
echo "---------------------------"
echo "Found [ $count ] IP range(s) over the threshold of [ $max ] on the CC Blacklist"
echo "Found [ $safe ] IP range(s) over the threshold of [ $max ] on the CC Whitelist"
echo
echo "Found [ $dcount ] CC Blacklisted IP Address(es) are being set to [ $ccblack ]"
# Skip Match Process if dedup=yes as it will create duplicates
if [ "$dedup" == "yes" ]; then mcount=Skipped; fi
echo "Found [ $mcount ] CC Whitelisted IP Address(es) are being set to [ $ccwhite ]"
if [ "$ccblack" == "block" ]; then
        echo; echo "Removed the following IP Ranges"
        cat $dupfile | tr '\n' '|'; echo
else
        echo "Skipped, CCBlack set to [ $ccblack ]"
fi
 
echo "---------------------------"
cocount=$(grep -cv "^1\.1\.1\.1" $pfdir$outfile)
echo "Post /24 Count   [ $cocount ]"
fi
}
 
##########
# Process to remove Duplicate Entries on each downloaded Blocklist Individually
duplicate(){
 
# Checks to see if Masterfile has data and doesn't contain Existing Blocklist
dupcheck=yes
hcheck=$(grep -c ^ $masterfile); if [ "$hcheck" -eq "0" ]; then dupcheck=no; fi
lcheck=$(grep -m 1 $header $masterfile ); if [ "$lcheck" == "" ]; then dupcheck=no; fi
 
if [ "$dupcheck" == "yes" ]; then
        grep $header $masterfile > $tempfile
        awk 'FNR==NR{a[$0];next}!($0 in a)' $tempfile $masterfile > $tempfile2; mv -f $tempfile2 $masterfile
        sed 's/^.* //' $masterfile > $mastercat
fi
if [ "$dup" == "no" ]; then
        sed -e 's/^/'$header' /' $pfdir$outfile  >> $masterfile
        sed 's/^.* //' $masterfile > $mastercat
else
        if [ ! "$hcheck" -eq "0" ]; then
                $pathgrepcidr -vf $mastercat $pfdir$outfile > $tempfile; mv -f $tempfile $pfdir$outfile
        fi
        sed -e 's/^/'$header' /' $pfdir$outfile >> $masterfile
        sed 's/^.* //' $masterfile > $mastercat
fi
 
countm=$(grep -c $header $masterfile); counto=$(grep -c ^ $pfdir$outfile)
if [ "$countm" == "$counto" ]; then sanity="Passed" || sanity=" ==> FAILED <== "; fi
echo; echo "Post Duplication count"; echo "---------------------------"
echo "Masterfile Count [ $countm ]"
echo "Outfile Count    [ $counto ]      [ $sanity ]"
echo "----------------------------------------------------------------"
}
 
# ================================================================
# After all Scheduled Downloads - pdeduplication & ddeduplication
# ================================================================
 
##########
# Process to perform a final De-Duplication on all of the BlockLists (Excluding Country Whitelist) ("pmax" variable).
pdeduplication(){
> $tempfile; > $tempfile2; > $dupfile; > $addfile; > $dedupfile; count=0; dcount=0
data="$(find $pfdir ! -name "p24*" ! -name "e_t*" -type f | xargs cut -d '.' -f 1-3 |
        awk -v pmax="$pmax" '{a[$0]++}END{for(i in a){if(a[i] > pmax){print i}}}' | grep -v "^1\.1\.1")"
count=$(echo "$data" | grep -c ^)
if [ "$data" == "" ]; then count=0; fi
# Find Repeat Offenders in each individual Blocklist Outfile
for ip in $data; do
        pcount=1; ii=$(echo "^$ip." | sed 's/\./\\\./g')
        list=$(find $pfdir ! -name "p24*" ! -name "e_t*" -type f | xargs grep -al $ii)
        for blfile in $list; do
                header=$(echo "${blfile##*/}" | cut -d '.' -f1)
                grep $ii $blfile > $tempfile
                awk 'FNR==NR{a[$0];next}!($0 in a)' $tempfile $blfile > $tempfile2; mv -f $tempfile2 $blfile
                if [ "$pcount" -eq "1" ]; then
                        echo $ip".0/24" >> $blfile
                        echo $header" $ip." >> $dedupfile
                        echo $header" "$ip".0/24" >> $addfile
                        pcount=2
                else
                        echo $header" $ip." >> $dedupfile
                fi
        done
done
# Remove Repeat Offenders in Masterfile
if [ -s "$dedupfile" ]; then
        > $tempfile; > $tempfile2
        sed 's/\./\\\./g' $dedupfile > $tempfile2
        while IFS=' ' read -r ips; do grep "$ips" $masterfile >> $tempfile; done < $tempfile2
        dcount=$(grep -c ^ $tempfile)
        awk 'FNR==NR{a[$0];next}!($0 in a)' $tempfile $masterfile > $tempfile2; mv -f $tempfile2 $masterfile
        cat $addfile >> $masterfile
        sed 's/^.* //' $masterfile > $mastercat
fi
echo; echo "Found [ $count ] IP range(s) over the threshold of pmax= [ $pmax ]"
echo "Found [ $dcount ] IP Address(es) are being set to [ block ]"
if [ -s "$addfile" ]; then
        echo; echo "Removed the following IP Ranges"
        sed -e 's/^.* //' -e 's/0\/24//' $addfile | tr '\n' '|'; echo
fi
count=$(grep -c ^ $masterfile)
echo; echo "   [ Post p-Deduplication count ]  [ $count ]"
}
 
##########
# De-Duplication utilizing MaxMind GeoIP Country Code Whitelisting ("dmax" variable)
deduplication(){
> $tempfile; > $tempfile2; > $dupfile; > $addfile; > $dedupfile; > $matchfile; > $tempmatchfile; count=0; dcount=0; mcount=0; mmcount=0
echo; echo "Querying for Repeat Offenders"
data="$(find $pfdir ! -name "p24*" ! -name "e_t*" -type f | xargs cut -d '.' -f 1-3 |
        awk -v dmax="$dmax" '{a[$0]++}END{for(i in a){if(a[i] > dmax){print i}}}' | grep -v "^1\.1\.1")"
count=$(echo "$data" | grep -c ^)
if [ "$data" == "" ]; then count=0; fi
safe=0
# Classify Repeat Offenders by Country Code
if [ -f $pathgeoipdat ]; then
        echo "Classifying Repeat Offenders by GeoIP"
        for ip in $data; do
                ccheck=$($pathgeoip -f $pathgeoipdat "$ip.1" | cut -c 24-25)
                case "$cc" in
                        *$ccheck*)
                                safe=$(($safe + 1))
                                if [ "$ccwhite" == "match" -o "$ccblack" == "match" ]; then
                                        echo "$ip." >> $matchfile
                                fi;;
                        *)
                                echo "$ip." >> $dupfile;;
                esac
        done
else
        echo; echo "Maxmind Binary Database Missing [ $pathgeoipdat ], skipping d-dedup Process"; echo
fi
if [ -s "$matchfile" ]; then
        echo "Processing [ Match ] IPs"
        match=$(sed -e 's/^/^/' -e 's/\./\\\./g' $matchfile)
        for mfile in $match; do
                find $pfdir ! -name "p24*" ! -name "e_t*" -type f | xargs grep $mfile >> $tempfile
        done
        sed 's/$/0\/24/' $matchfile >> $tempmatchfile
        sed -e 's/.*://' -e 's/^/\!/' $tempfile >> $tempmatchfile
        mv -f $tempmatchfile $pfmatch$matchdedup
        mcount=$(grep -c ^ $tempfile)
        mmcount=$(($mcount + $mmcount))
fi
# Find Repeat Offenders in each individual Blocklist Outfile
if [ -s "$dupfile" ]; then
        echo "Processing [ Block ] IPs"
        dup=$(cat $dupfile)
        for ip in $dup; do
                pcount=1; ii=$(echo "^$ip" | sed 's/\./\\\./g')
                list=$(find $pfdir ! -name "p24*" ! -name "e_t*" -type f | xargs grep -al $ii)
                for blfile in $list; do
                        header=$(echo "${blfile##*/}" | cut -d '.' -f1)
                        grep $ii $blfile > $tempfile
                        if [ "$ccblack" == "block" ]; then
                                awk 'FNR==NR{a[$0];next}!($0 in a)' $tempfile $blfile > $tempfile2; mv -f $tempfile2 $blfile
                                if [ "$pcount" -eq "1" ]; then
                                        echo $ip"0/24" >> $blfile
                                        echo $header" "$ip >> $dedupfile
                                        echo $header" "$ip"0/24" >> $addfile
                                        pcount=2
                                else
                                        echo $header" "$ip >> $dedupfile
                                fi
                        else
                                if [ "$pcount" -eq "1" ]; then
                                        matchoutfile="match"$header".txt"
                                        echo $ip"0/24" >> $pfmatch$matchoutfile
                                        sed 's/^/\!/' $tempfile >> $pfmatch$matchoutfile
                                        mcount=$(grep -c ^ $pfmatch$matchoutfile)
                                        mmcount=$(($mcount + $mmcount))
                                        pcount=2
                                fi
                        fi
                done
        done
        # Remove Repeat Offenders in Masterfiles
        if [ -s "$dedupfile" ]; then
                echo "Removing   [ Block ] IPs"
                > $tempfile; > $tempfile2
                sed 's/\./\\\./g' $dedupfile > $tempfile2
                while IFS=' ' read -r ips; do grep "$ips" $masterfile >> $tempfile; done < $tempfile2
                dcount=$(grep -c ^ $tempfile)
                awk 'FNR==NR{a[$0];next}!($0 in a)' $tempfile $masterfile > $tempfile2; mv -f $tempfile2 $masterfile
                cat $addfile >> $masterfile
                sed 's/^.* //' $masterfile > $mastercat
        fi
fi
 
echo; echo "Found [ $count ] IP range(s) over the threshold of dmax= [ $dmax ]"
echo "Found [ $safe ] IP range(s) classified as Whitelisted"
echo; echo "Found [ $dcount ] CC Blacklisted IP Address(es) are being set to [ $ccblack ]"
echo "Found [ $mmcount ] CC Whitelisted IP Address(es) are being set to [ $ccwhite ]"; echo
if [ -s "$addfile" ]; then
        echo; echo "Removed the following IP Ranges"
        sed -e 's/^.* //' -e 's/0\/24//' $addfile | tr '\n' '|'; echo
fi
count=$(grep -c ^ $masterfile)
echo "   [ Post d-Deduplication count ]  [ $count ]"
}
 
# ================================================================
#       MAIN Collect Process to call all other functions
# ================================================================
 
# Main Collection process to download Blocklists and call appropriate Sub-Process(es)
collect(){
 
# Set varibles from Collect $2
switch=$(echo $2 | tr '|' '\n'); y=1; proceed=0
for line in $switch; do
        case "$y" in
                1)      header=$line;;
                2)      lowcase=$(echo $line | tr '[A-Z]' '[a-z]')
                        group=$lowcase;;
                3)      addr=$line;;
                4)      infile=$line;;
                5)      lowcase=$(echo $line | tr '[A-Z]' '[a-z]')
                        process=$lowcase;;
                6)      lowcase=$(echo $line | tr '[A-Z]' '[a-z]')
                        p24=$lowcase
                        if [ ! "$p24" == "yes" -o ! "$p24" == "no" ]; then p24=yes; fi;;
                7)      lowcase=$(echo $line | tr '[A-Z]' '[a-z]')
                        dup=$lowcase
                        if [ ! "$dup" == "yes" -o ! "$dup" == "no" ]; then dup=yes; fi;;
                8)      lowcase=$(echo $line | tr '[A-Z]' '[a-z]')
                        atype=$lowcase;;
        esac
        y=$(($y + 1))
done
 
# Check Scheduler
outfile=$header".txt"
if [ "$p24" == "no" ]; then outfile="p24"$header".txt"; fi
if [ "$1" == "24" ]; then
        proceed=1
else
        case "$1" in
        *$now*) proceed=1;;
        esac
fi
 
# Capture Group INFO
casegroup
 
# Set proceed = 1 to bypass schedule
if [ "$bypass" == "yes" ]; then proceed=1; fi
 
# If a new Blocklist is selected, bypass scheduler
if [ ! -f "$workdir$infile" ]; then proceed=1; fi
 
# Check if list to be removed with Collect $3
if [ "$3" == "remove" ]; then
        grep $header $masterfile > $tempfile
        awk 'FNR==NR{a[$0];next}!($0 in a)' $tempfile $masterfile > $tempfile2; mv -f $tempfile2 $masterfile
        sed 's/^.* //' $masterfile > $mastercat
        rm -r $pforigdir$outfile; rm -r $pfdir$header".txt"; rm -r $workdir$infile
        echo; echo "The Following list has been REMOVED [ $header ]"; echo
        proceed=0
fi
 
# Check Header Name to meet Unique Criteria before Downloading
headerchk=$(grep $header $masterfile | cut -d ' ' -f1 | sort | uniq | grep -c ^)
if [ "$headerchk" -gt "1" ]; then echo; echo "Cannot add [ $header ] Header Name is not Unique"; proceed=0; echo; fi
 
if [ "$proceed" == "1" ]; then
        if [ "$dskip" == "yes" ]; then
                if [ -f $workdir$infile ]; then
                        echo; echo "Using Previously Downloaded List [ $header ]"; returncode=0
                else
                        echo; echo "Attempt to use previous Download Failed. File not found"; returncode=1
                fi
        else
                if [ "$atype" == "fa" ]; then
                        if [ "$dmethod" == "fetch" ]; then $pathfetch -v -o $workdir$infile -T 20 $addr
                        elif [ "$dmethod" == "wget" ]; then $pathwget --no-check-certificate -T 20 -O $workdir$infile $addr
                                else echo "No download method chosen"; returncode=1
                        fi
                elif [ "$atype" == "faf" ]; then
                        if [ "$dmethod" == "fetch" ]; then $pathfetch -v -o $workdir$infile -T 20 $addr$infile
                        elif [ "$dmethod" == "wget" ]; then $pathwget --no-check-certificate -T 20 -O $workdir$infile $addr$infile
                                else echo "No download method chosen"; returncode=1
                        fi
                elif [ "$atype" == "local" ]; then cp $addr$infile $workdir$infile; returncode=0; echo; echo "Processing Local File [ $header ]"; echo
                elif [ "$atype" == "processlocal" ]; then
                        find $addr -name '*bot*' -o -name '*ciarmy*' -o -name '*compromised*' -o -name '*drop*' -o -name '*dshield*' -o -name '*portgrouped*' |
                                xargs cat > $workdir$infile
                        returncode=0
                        echo; echo "Processing Local File [ $header ]"; echo
                elif [ "$atype" == "rsync" ]; then
                        echo "Processing RSYNC transfer [ $header ]"
                        $pathrsync $addr$infile $workdir$infile
                        returncode=$?
                else
                        echo "No download method chosen"; returncode=1
                fi
        fi
        returncode=$?; event=$(date +%y-%m-%d,); eventnow=$(date +%H:%M)
        if ! grep -sq $event$header"-" $logfile; then echo -e $event$header"-" >> $logfile; fi
        logentry=$(grep "$event"$header"-" $logfile)
        if [ "$returncode" -eq "0" ]; then
                "$process"
                process255
                sort -t . -k 1,1n -k 2,2n -k 3,3n -k 4,4n $pfdir$outfile | uniq > $tempfile; mv -f $tempfile $pfdir$outfile
                if [ "$p24" == "yes" -a "$globalp24" == "no" ]; then process24; fi
                duplicate
                # check for empty blocklist file, if empty write 1.1.1.1 in blocklist file
                [ ! -s $pfdir$outfile ] && echo 1.1.1.1 > $pfdir$outfile
                count=$(grep -cv "1\.1\.1\.1" $pfdir$outfile)
                sed -i '' -e "s/$logentry/$logentry $eventnow $count,/" $logfile
                echo
        else
                echo; echo " ===>>  Download Failed  <<==="
                if [ "$plog" == "yes" ]; then $pathlogger -t pfIPrep "Download Failed on List [ $header ]"; fi
                echo; sed -i '' -e "s/$logentry/$logentry $eventnow FAIL,/" $logfile
                [ ! -s $pfdir$outfile ] && echo 1.1.1.1 >> $pfdir$outfile
        fi
else
        # Write "1.1.1.1" to the Not downloaded Blocklist File
        [ ! -s $pfdir$outfile ] && echo 1.1.1.1 >> $pfdir$outfile
fi
clearvars
}
 
 
# ================================================================
#                      FINAL Closing Process
# ================================================================
 
closingprocess(){
# Add Original File Lists + IBlock var "fcount" for Final - Original Count
# IBlock List Counts limited to when the Scheduler Downloads these lists.
fcount=$(find $pforigdir ! -name "IBlock*" -type f | xargs cat | grep -c ^)
fcount=$(($ficount + $fcount))
echo; echo "===[ FINAL Processing ]==============================";
echo; echo "   [ Original count   ]  [ $fcount ]"
count=$(grep -c ^ $masterfile)
echo; echo "   [ Processed Count  ]  [ $count ]"; echo
if [ "$pdup" == "yes" ]; then
        echo "===[ p-Deduplication Process ]======================="
        pdeduplication
        echo
fi
if [ "$dedup" == "yes" ]; then
        echo "===[ d-Deduplication Process ]======================="
        deduplication
        echo
fi
 
# Write "1.1.1.1" to the Not downloaded Blocklist File
emptyfiles=$(find $pfdir ! -name "e_t*" -type f -size 0)
for i in $emptyfiles; do echo "1.1.1.1" > $i; done
 
s1=$(grep -c ^ $masterfile)
s2=$(find $pfdir ! -name "e_t*" -type f | xargs grep -v "1\.1\.1\.1" | grep -c ^)
s3=$(sort $mastercat | uniq -d | tail -30)
s4=$(find $pfdir ! -name "e_t*" -type f | grep -v "1\.1\.1\.1" | sort | uniq -d | tail -30)
 
echo "===[ Blocklist IP Counts ]==========================="; echo
find $pfdir ! -name "e_t*" -type f | xargs wc -l | sort -n -r; echo
echo; echo "            Empty Lists w/1.1.1.1"
echo "================================================"; echo
echo "Sanity Check   ** These two Counts should Match! **"
echo "------------"
echo "Masterfile Count [ $s1 ]"
echo "pf folder Count  [ $s2 ]"; echo
echo "Duplication Sanity Check (Pass=No IPs reported)"
echo "------------------------"
echo "Masterfile/pf Folder Uniq check"
if [ ! -z "$s3" ]; then echo $s3; fi
echo "pf folder/Masterfile Uniq check"
if [ ! -z "$s4" ]; then echo $s4; fi
echo; echo "Sync Check (Pass=No IPs reported)"
echo "----------"
find $pfdir ! -name "e_t*" -type f | xargs grep -hv "1\.1\.1\.1" > $syncfile
echo "Missing IPs in Mastercat"
awk 'FNR==NR{a[$0];next}!($0 in a)' $syncfile $mastercat | tail -30
echo "Missing IPs in pf folder"
awk 'FNR==NR{a[$0];next}!($0 in a)' $mastercat $syncfile | tail -30
echo
 
sort -u -o $masterfile $masterfile
sort -t . -k 1,1n -k 2,2n -k 3,3n -k 4,4n $mastercat > $tempfile; mv -f $tempfile $mastercat
 
# Comment-out Blocklists that are removed
script=$(basename $0)
sed -i '' '/^collect.*remove/ s/^/#/' $userfolder/$script
 
# Process to copy Mastercat Block lists to Snort IPRep Folder
# Restart pfSense Snort Enabled Interfaces to reload new IPRep Blocklists
if [ "$snort" == "yes" ]; then
        echo "Sending SIGHUP to SNORT"
        cp $mastercat $snortlist
        pkill -HUP snort
fi
 
# Process to copy Mastercat Blocklist to OSSEC-HIDS Folder
if [ "$ossec" == "yes" ]; then
        sed "s/0\/24/$ossectxt/" $mastercat > $osseclist
fi
 
# Build MasterMatch File from Match folder and Deduplication Matchs.
if [ "$ccwhite" == "match" -o "$ccblack" == "match" -a -f $pathgeoipdat ]; then
        awk '{ print $1 }' $pfmatch* | sort | awk '{print $1 " " $2;}' | sort -n > $tempfile; mv -f $tempfile $mastermatch
fi
 
# Update Group Files if Sanity Check Pass
if [ "$s1" == "$s2" -a "$s3" == "$s4" ]; then
        echo; echo "===>  Sanity Checks PASSED, Updating Group Lists  <==="; echo
        > $tempfile; count=1
        tier1="$tier1 End"; tier2="$tier2 End"; tier3="$tier3 End"; tier4="$tier4 End"; tier5="$tier5 End"
        tier6="$tier6 End"; tier7="$tier7 End"; tier8="$tier8 End"; tier9="$tier9 End"; tier10="$tier10 End"
        for i in $tier1 $tier2 $tier3 $tier4 $tier5 $tier6 $tier7 $tier8 $tier9 $tier10; do
                if [ "$i" == "End" ]; then count=3; fi
                if [ "$count" -eq "1" ]; then
                        groupname=$i; count=2
                elif [ "$count" -eq "2" ]; then
                        updatechk=$(find $pfdir$i".txt" -mmin -20)
                        if [ "$updatechk" == "$pfdir$i".txt"" ]; then passupdate=yes; fi
                        tierlist="$tierlist $i"
                elif [ "$count" == "3" ]; then
                        if [ "$passupdate" == "yes" ]; then
                                echo "Updating   [ $groupname ] [ $tierlist ]"
                                for list in $tierlist; do
                                        grep -v "^1\.1\.1\.1" $pfdir$list".txt" >> $tempfile
                                done
                                if [ ! -f $aliasdir$groupname ]; then touch $aliasdir$groupname; fi
                                mv -f $tempfile $aliasdir$groupname
                                # Reload pf Table (pfSense)
                                if [ "$pfupdate" == "yes" ]; then
                                        if [ -x $pathpfctl ]; then
                                                $pathpfctl -t $groupname -T replace -f $aliasdir$groupname
                                        else
                                                echo; echo "pfctl not found, To disable set [ pfupdate=no ]"
                                        fi
                                        echo
                                fi
                        else
                                echo   "No Updates [ $groupname ]"; echo
                        fi
                        count=1; passupdate=""; updatechk=""; tierlist=""; groupname=""; > $tempfile
                fi
        done
else
        if [ "$plog" == "yes" ]; then $pathlogger -t pfIPrep "Sanity Checks FAILED, No Updates to Tables"; fi
        echo; echo "===>  Sanity Checks FAILED, No Updates to Tables  <==="; echo
fi
 
echo; echo "Alias Table IP Counts (w/o 1.1.1.1)"; echo "-----------------------------"
find $aliasdir ! -iname "*match*" -type f | xargs wc -l | sort -n -r
 
if [ -f $mastermatch ]; then
        echo; echo "Alias Table (Match) IP Counts"; echo "-----------------------------"
        cp $mastermatch $aliasdir$matchgroup
        find $aliasdir -iname "*match*" -type f | xargs wc -l | sort -n -r
else
        rm $aliasdir$matchgroup
fi
 
# Report Table Entry Allocation and Usage Stats.
if [ "$pfupdate" == "yes" ]; then
        echo; echo "pfSense Table Stats"; echo "-------------------"
        $pathpfctl -s memory | grep "table-entries"
        pfctlcount=$($pathpfctl -vvsTables | awk '/Addresses/ {s+=$2}; END {print s}')
        echo "Table Usage Count       " $pfctlcount; echo
fi
 
# Check MaxMind CountryCode Database Age
if [ -f $pathgeoipccdata ]; then find $pathgeoipccdata -mtime +31 | xargs echo Country Code CSV is OUT OF DATE;fi
if [ -f $pathgeoipdat ]; then find $pathgeoipdat -mtime +31 | xargs echo Country Code Binary is OUT OF DATE; fi
 
now=$(date); echo; echo; echo "**** UPDATE PROCESS ENDED - " $now " ****"; echo
 
# Manage download log file to max number of lines variable
linecount=$(grep -c ^ $downloadlog)
if [ "$linecount" -gt "$maxlines" ]; then
        tail -n $maxlines $downloadlog > $tempfile; mv -f $tempfile $downloadlog
fi
# Remove pfIPrep LOCK File
rm -f $pfipreplock
}
